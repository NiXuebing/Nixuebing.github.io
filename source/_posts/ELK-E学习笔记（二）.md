---
title: ELK-E学习笔记（二）
date: 2019-01-10 10:56:54
author: ACE NI
tags:
  - ELK
categories:
  - 高并发架构
---



# 搜索

## 空搜索

```js
GET /_search
```

它简单地返回集群中所有索引下的所有文档。

`hits`

结果集：它 包含 `total` 字段来表示匹配到的文档总数，并且一个 `hits` 数组包含所查询结果的前十个文档。

`took`

执行整个搜索请求耗费了多少毫秒

`shards`

在查询中参与分片的总数，以及这些分片成功了多少个失败了多少个。正常情况下我们不希望分片失败，但是分片失败是可能发生的。

`timeout`

查询是否超时。默认情况下，搜索请求不会超时。 如果低响应时间比完成结果更重要，你可以指定 `timeout` 为 10 或者 10ms（10毫秒），或者 1s（1秒）：

```js
GET /_search?timeout=10ms
```

**应当注意的是 `timeout` 不是停止执行查询，它仅仅是告知正在协调的节点返回到目前为止收集的结果并且关闭连接。在后台，其他的分片可能仍在执行查询即使是结果已经被发送了。**

**使用超时是因为 SLA(服务等级协议)对你是很重要的，而不是因为想去中止长时间运行的查询。**

<!-- more -->

## 多索引，多类型

```
/_search
```

在所有的索引中搜索所有的类型

```
/gb/_search
```

在 `gb` 索引中搜索所有的类型

```
/gb,us/_search
```

在 `gb` 和 `us` 索引中搜索所有的文档

```
/g*,u*/_search
```

在任何以 `g` 或者 `u` 开头的索引中搜索所有的类型

```
/gb/user/_search
```

在 `gb` 索引中搜索 `user` 类型

```
/gb,us/user,tweet/_search
```

在 `gb` 和 `us` 索引中搜索 `user` 和 `tweet` 类型

```
/_all/user,tweet/_search
```

在所有的索引中搜索 `user` 和 `tweet` 类型

## 分页

```js
GET /_search?size=5&from=10
```

理解为什么深度分页是有问题的，我们可以假设在一个有 5 个主分片的索引中搜索。 当我们请求结果的第一页（结果从 1 到 10 ），每一个分片产生前 10 的结果，并且返回给 *协调节点* ，协调节点对 50 个结果排序得到全部结果的前 10 个。

现在假设我们请求第 1000 页--结果从 10001 到 10010 。所有都以相同的方式工作除了每个分片不得不产生前10010个结果以外。 然后协调节点对全部 50050 个结果排序最后丢弃掉这些结果中的 50040 个结果。

可以看到，在分布式系统中，对结果排序的成本随分页的深度成指数上升。这就是 web 搜索引擎对任何查询都不要返回超过 1000 个结果的原因。

## 倒排索引

一个倒排索引由文档中**所有不重复词**的列表构成，对于其中每个词，有一个包含它的文档列表。

```
Term      Doc_1  Doc_2
-----------------------
Quick   |       |  X
The     |   X   |
brown   |   X   |  X
dog     |   X   |
dogs    |       |  X
fox     |   X   |
foxes   |       |  X
in      |       |  X
jumped  |   X   |
lazy    |   X   |  X
leap    |       |  X
over    |   X   |  X
quick   |   X   |
summer  |       |  X
the     |   X   |
----------------------
```

## 分析器

字符过滤器 ： 一个字符过滤器可以用来去掉HTML，或者将 `&` 转化成 `and`。

分词器 ： 一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。

Token过滤器 ： 这个过程可能会改变词条（例如，小写化 `Quick` ），删除词条（例如， 像 `a`， `and`， `the` 等无用词），或者增加词条（例如，像 `jump` 和 `leap` 这种同义词）。

## 映射

Elasticsearch 支持 如下简单域类型：

- 字符串: `string`
- 整数 : `byte`, `short`, `integer`, `long`
- 浮点数: `float`, `double`
- 布尔型: `boolean`
- 日期: `date`

| **JSON type**                  | **域 type** |
| ------------------------------ | ----------- |
| 布尔型: `true` 或者 `false`    | `boolean`   |
| 整数: `123`                    | `long`      |
| 浮点数: `123.45`               | `double`    |
| 字符串，有效日期: `2014-09-15` | `date`      |
| 字符串: `foo bar`              | `string`    |

自定义映射允许你执行下面的操作：

- 全文字符串域和精确值字符串域的区别
- 使用特定语言分析器
- 优化域以适应部分匹配
- 指定自定义数据格式
- 还有更多

域最重要的属性是 `type` 。对于不是 `string` 的域，你一般只需要设置 `type`

`string` 域映射的两个最重要 属性是 `index` 和 `analyzer` 。（ES5后把string域拆分为`keyword`和`text`）

`index` 属性控制怎样索引字符串。它可以是下面三个值：

- `analyzed`

  首先分析字符串，然后索引它。换句话说，以全文索引这个域。

- `not_analyzed`

    索引这个域，所以它能够被搜索，但索引的是精确值。不会对它进行分析。

- `no`

  不索引这个域。这个域不会被搜索到。

对于 `analyzed` 字符串域，用 `analyzer` 属性指定在搜索和索引时使用的分析器。默认， Elasticsearch 使用 `standard` 分析器， 但你可以指定一个内置的分析器替代它，例如 `whitespace` 、 `simple` 和 `english`

**尽管你可以 *增加_ 一个存在的映射，你不能 _修改* 存在的域映射。如果一个域的映射已经存在，那么该域的数据可能已经被索引。如果你意图修改这个域的映射，索引的数据可能会出错，不能被正常的搜索。**



对于数组，没有特殊的映射需求。任何域都可以包含0、1或者多个值，就像全文域分析得到多个词条。

但是，数组是以多值域 *索引*的—可以搜索，但是无序的。 在搜索的时候，你不能指定 “第一个” 或者 “最后一个”。

对象：Lucene 不理解内部对象。文档是由一组键值对列表组成的。

为了能让 Elasticsearch 有效地索引内部类，它把我们的文档转化成这样：

```js
{
    "tweet":            [elasticsearch, flexible, very],
    "user.id":          [@johnsmith],
    "user.gender":      [male],
    "user.age":         [26],
    "user.name.full":   [john, smith],
    "user.name.first":  [john],
    "user.name.last":   [smith]
}
```

内部对象的数组：

```js
{
    "followers": [
        { "age": 35, "name": "Mary White"},
        { "age": 26, "name": "Alex Jones"},
        { "age": 19, "name": "Lisa Smith"}
    ]
}
```

会被扁平化处理：

```js
{
    "followers.age":    [19, 26, 35],
    "followers.name":   [alex, jones, lisa, smith, mary, white]
}
```

## 过滤&查询

当使用于 *过滤情况* 时，查询被设置成一个“不评分”或者“过滤”查询。

当使用于 *查询情况* 时，查询就变成了一个“评分”的查询。

在一般情况下，一个filter 会比一个评分的query性能更优异，并且每次都表现的很稳定。

从 Elasticsearch 2.0 开始，过滤（filters）已经从技术上被排除了，同时所有的查询（queries）拥有变成不评分查询的能力。

`match` & `term`

在一个全文字段上使用 `match` 查询，在执行查询前，它将用正确的分析器去分析查询字符串;在一个精确值的字段上使用它， 例如数字、日期、布尔或者一个 `not_analyzed` 字符串字段，那么它将会精确匹配给定的值。

 `term` 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些 `not_analyzed` 的字符串。

## 相似度

Elasticsearch 的相似度算法 被定义为检索词频率/反向文档频率， *TF/IDF* ，包括以下内容：

- 检索词频率

  检索词在该字段出现的频率？出现频率越高，相关性也越高。 字段中出现过 5 次要比只出现过 1 次的相关性高。

- 反向文档频率

  每个检索词在索引中出现的频率？频率越高，相关性越低。检索词出现在多数文档中会比出现在少数文档中的权重更低。

- 字段长度准则

  字段的长度是多少？长度越长，相关性越低。 检索词出现在一个短的 title 要比同样的词出现在一个长的 content 字段权重更大。

## 分布式检索

游标查询

游标查询会取某个时间点的快照数据。 查询初始化之后索引上的任何变化会被它忽略。 它通过保存旧的数据文件来实现这个特性，结果就像保留初始化时的索引 *视图* 一样。

注意游标查询每次返回一个新字段 `_scroll_id`。每次我们做下一次游标查询， 我们必须把前一次查询返回的字段 `_scroll_id` 传递进去。 当没有更多的结果返回的时候，我们就处理完所有匹配的文档了。









